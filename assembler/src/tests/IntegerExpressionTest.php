<?php

/**
 *   888b     d888  .d8888b.   .d8888b.      d8888  888    d8P
 *   8888b   d8888 d88P  Y88b d88P  Y88b    d8P888  888   d8P
 *   88888b.d88888 888    888 888          d8P 888  888  d8P
 *   888Y88888P888 888        888d888b.   d8P  888  888d88K
 *   888 Y888P 888 888        888P "Y88b d88   888  8888888b
 *   888  Y8P  888 888    888 888    888 8888888888 888  Y88b
 *   888   "   888 Y88b  d88P Y88b  d88P       888  888   Y88b
 *   888       888  "Y8888P"   "Y8888P"        888  888    Y88b
 *
 *    - 64-bit 680x0-inspired Virtual Machine and assembler -
 */

declare(strict_types = 1);

namespace ABadCafe\MC64K\Tests;
use ABadCafe\MC64K\Utils\TestCase;
use ABadCafe\MC64K\Parser\Utils;
/**
 * IntegerExpressionTest
 *
 * Tests the ConstIntExpression processing
 */
class IntegerExpressionTest extends TestCase {

    const CASES = [
        // These cases should be left untouched
        "1"  => "1",
        "-1" => "-1",
        "-0" => "-0",

        // NOT
        "~0" => "-1",
        "~1" => "-2",
        "~-1" => "0",

        // AND
        "0&0" => "0",
        "0&1" => "0",
        "1&0" => "0",
        "1&1" => "1",
        "0xFF&0x0F" => "15",

        // OR
        "0|0" => "0",
        "0|1" => "1",
        "1|0" => "1",
        "1|1" => "1",
        "0xF0|0x0F" => "255",

        // EOR
        "0^0" => "0",
        "0^1" => "1",
        "1^0" => "1",
        "1^1" => "0",
        "0xF0^0x0F" => "255",
        "0xFF^0x0F" => "240",

        // Addition
        "1+-2" => "-1",
        "1+-1" => "0",
        "1+0" => "1",
        "1+1" => "2",
        "1+2" => "3",
        "-2+1" => "-1",
        "-1+1" => "0",
        "0+1" => "1",
        "1+1" => "2",
        "2+1" => "3",

        // Subtraction
        "1- -2" => "3",
        "1- -1" => "2",
        "1-1" => "0",
        "1-2" => "-1",
        "-2-1" => "-3",
        "-1-1" => "-2",
        "0-1" => "-1",
        "1-1" => "0",
        "2-1" => "1",

        // Simple Multiplication
        "1*0" => "0",
        "0*1" => "0",
        "1*1" => "1",
        "-1*1" => "-1",
        "1*-1" => "-1",
        "-1*-1" => "1",
        "1*2" => "2",
        "1*3" => "3",
        "1*4" => "4",
        "-1*2" => "-2",
        "1*-3" => "-3",
        "-1*-4" => "4",
        "2*2" => "4",
        "2*3" => "6",
        "2*4" => "8",
        "-2*2" => "-4",
        "2*-3" => "-6",
        "-2*-4" => "8",

        // Simple Division
        "0/1"   => "0",
        "1/1"   => "1",
        "-1/1"  => "-1",
        "1/-1"  => "-1",
        "-1/-1" => "1",
        "1/2"   => "0",
        "2/1"   => "2",
        "3/2"   => "1",
        "5/2"   => "2",
        "6/2"   => "3",
        "-1/2"   => "0",
        "2/-1"   => "-2",
        "-3/2"   => "-1",
        "-5/-2"   => "2",

        // Simple Modulo
        "0%1"   => "0",
        "1%1"   => "0",
        "-1%1"  => "0",
        "1%-1"  => "0",
        "-1%-1" => "0",
        "1%2"   => "1",
        "2%1"   => "0",
        "3%2"   => "1",
        "5%2"   => "1",
        "6%2"   => "0",
        "-1%2"   => "-1",
        "2%-1"   => "0",
        "-3%2"   => "-1",
        "-5%-2"   => "-1",

        // Simple shifts
        "0<<1" => "0",
        "0>>1" => "0",
        "1<<0" => "1",
        "1<<1" => "2",
        "1<<2" => "4",
        "1<<3" => "8",
        "256>>1" => "128",
        "256>>2" => "64",
        "256>>3" => "32",
        "256>>4" => "16",
        "255>>5" => "7",
        "12>>1" => "6",
        "12>>2" => "3",
        "12>>3" => "1",

        // Order of precedence
        "2*3+1" => "7",
        "1+2*3" => "7",
        "2*3/2" => "3",
        "3*2/2" => "3",
        "2*3/6" => "1",
        "1<<1+3" => "16",
        "[1<<1]+3" => "5"
    ];

    /**
     * @inheritDoc
     */
    public function run(): void {
        $oParser = new Utils\ConstIntExpression();
        foreach(self::CASES as $sCase => $sExpect) {
            if ($this->isVerbose()) {
                echo "\t", $sCase, " => ", $sExpect, "\n";
            }
            $this->assertSame(
                $sExpect,
                $oParser->parse((string)$sCase)
            );
        }

    }
}

