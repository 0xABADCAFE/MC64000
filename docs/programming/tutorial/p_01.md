[Documentation](../../README.md) > [Programming](../README.md) > [Tutorials](../Tutorials.md)

## Tutorial 1 : Getting Started

### Create a new Project

The first step is to create a new project:

* Start by making a suitable location structure.
* It is suggested, but not required, that you create a subdirectory for the source files.
* We need to create a project file.
    - This file is used by masm to understand the build requirements of your application.
    - The project file is a basic JSON document, so use whichever text editor you prefer. We'll use nano.

```shell
:~/$ mkdir -p tutorial tutorial/src
:~/cd tutorial
:~/tutorial$ nano proj.json
```

The Project File must specify, at the absolute minimum the _target_ and a list of _sources_. The _target_ defines a number of important properties:

* The name, semantic version and output location of the binary.
* The name and semantic version of the host that will load and execute the binary.
    - We will specify the Standard Test Host 1.0.0 as our target.

```json
{
    "target": {
        "name": "Tutorial",
        "version": "1.0.0",
        "description": "My first MC64K application",
        "output": "tutorial.64x",
        "host": {
            "name": "Standard Test Host",
            "version": "1.0.0"
        }
    },
    "sources": [
        "src/main.s"
    ]
}
```

Next we need to write our actual program.

```bash
:~/tutorial$ nano src/main.s
```
The Standard Test Host requires that any binary defines two executable entry points:

* main
    - Execution begins here.
* exit
    - May be called in unexpected termination cases.

In order to advertise these, we use the `@export` directive, along with the `x` for executable qualifier.
The simplest program we can write is just to return cleanly to the host.

```asm
    ; tutorial MVP
    @export main x
    @export exit x
main:
exit:
    rts
```

### Assembling

Now we can assemble our binary. All going well, you should see the following output:

```shell
:~/tutorial$ ~/MC64000/assembler/masm proj.json
#0 Attempting to open project file proj.json...
#1 Project file proj.json loaded successfully:
	Name:   Tutorial
	Info:   My first MC64K application
	Output: tutorial.64x
	Files:  1
```

Checking the output file, you may be surprised to see that it's larger than you might reasonably expect at around ~250 bytes. The binary file is constructed of several 8-byte aligned chunks, including a manifest, target information, import list, export list and finally the assembled bytecode.

### Running

The next step is to execute the binary. Assuming the standard test host interpreter has been built, a significant amount of debug output will be generated. We'll suppress this for the first run.

```shell
:~/tutorial$ ~/MC64000/assembler/run64k tutorial.64x 2>/dev/null
:~/tutorial
```

This was likely a very disappointing exercise. Our program does not produce any output anyway so how do we even know it worked? Let's try again without suppressing stderr. You should see something like this followed by a machine state dump:

```shell
:~/tutorial$ ~/MC64000/assembler/run64k tutorial.64x
Loading object file as host 'Standard Test Host'
Linking 2 exported symbols...
	Matched    0 0x557e651bf230 [--x] main
	Matched    1 0x557e651bf230 [--x] exit
Runtime: Executable instance loaded at 0x557e651bf250 for binary 'tutorial.64x'
Stack of 256 allocated at 0x557e651be150 ... 0x557e651be250
Beginning run at PC:0x557e651bf230...
Total instructions 1 in 2072 nanoseconds, 0.48 MIPS
Machine State
	Program Counter: 0x557e651bf231 [... 0x07 > 0x00 < 0x00 ...]
	Call Depth:      0
	Status:          3 [Completed]
```

From this we can see that the test host loaded the binary, successfully matched the two required entry points and ran the code:

* We executed 1 instruction (rts)
* We exited with status 3 (Completed)
* We exited at the same call depth we started (0)
